# Sed

Sed全名stream editor，意为流编辑器，用来对文件进行过滤和替换操作，但一次只处理一行内容

* [Command Line](#command-line)
	* [使用多重指令的三种方式](#使用多重指令的三种方式)
	* [使用脚本文件 -f](#使用脚本文件--f)
	* [阻止自动输出 -n](#阻止自动输出--n)
	* [提前备份文件 -i](#提前备份文件--i)
* [语法](#语法)
	* [范围控制](#范围控制)
	* [范围嵌套](#范围嵌套)
* [操作](#操作)
	* [替换](#替换)
	* [追加、插入和替换](#追加插入和替换)
	* [转换操作](#转换操作)
	* [打印操作](#打印操作)
	* [打印行号](#打印行号)
	* [下一步next](#下一步next)
	* [追加下一行NEXT](#追加下一行next)
	* [多行删除](#多行删除)
	* [多行打印](#多行打印)
	* [读写文件](#读写文件)
	* [退出](#退出)
	* [保持空间](#保持空间)
	* [分支](#分支)
	* [测试](#测试)

## Command Line

### 使用多重指令的三种方式

    - sed 's/regular/complex/; s/regular/complex' file
    - sed -e 'instruction' -e 'instruction' -e 'instruction' file
    - sed '
        \> s/regualr/complex/
        \> instruction
        \> instruction' file

### 使用脚本文件 -f

    - sed -f scriptfile inputfile

### 阻止自动输出 -n

    - sed -n -e 's/regular/complex/p' file
    - * 能够使用p让它输出，同样的办法也可以在脚本中用#n

### 提前备份文件 -i

给文件加上SUFFIX后缀进行备份，然后在原文件上修改

## 语法

### 范围控制

sed使用的是范围+操作的格式，类似`/pattern1/s/pattern2/replacement/g`，表示在匹配pattern1前提的行上进行替换

  - 如果没有指定地址，那么命令将应用于每一行
  - 如果只有一个地址，那么命令应用于该地址匹配的任意行
  - 如果地址后面有感叹号，那么命令将应用于不匹配该地址的其他行
  - 如果指定了由逗号分隔的两个地址，那么命令将应用于匹配了第一个地址的第一行和它后面的指导匹配到第二个地址的行（包括此行）

几个例子
    - 1d
    - $d    * 删除最后一行
    - /^&/d     * 删除空行
    - /^\\.TS/,/^\\.TE/d
    - 50,$d
    - 1,/^&/!d
    - /---/!s/--/\\(em/g

### 范围嵌套

再指定行的范围之后，继续在这个范围里指定另一个地址来执行操作

```sed
/^\.TS/,/^\.TE/{
    /^&/d
}
```

注意：*左大括号必须在行末，而且右大括号本身必须单独占一行，并在之后没有空格*

## 操作

### 替换

    [address]s/pattern/replacement/flag

| replacement中的特殊符号 | <                                  |
|-------------------------|------------------------------------|
| &                       | pattern匹配到所有的内容            |
| \n                      | pattern中的第n个分组所匹配到的内容 |
| \                       | 用来转义特殊字符                   |


| flag   | <                                                                    |
|--------|----------------------------------------------------------------------|
| n      | 表示对文本的模式第n次匹配成功的情况进行替换，n可以是1到512           |
| g      | 对模式空间所有出现的情况进行全局更改，不加则只是对第一次匹配进行替换 |
| p      | 打印模式空间的内容                                                   |
| w file | 将模式空间的内容写到文件file中                                       |

有趣的例子：将该行中的第二个空格替换成换行符

```sed
    s/ /\
    /2
```

### 追加、插入和替换

    [address]a\
    text

    [address]i\
    text

    [address]c\
    text

以上操作都是以*行*为对象，并且每一个后面都跟一个反斜杠用于转义换行符，所以text必须从下一行开始

如果text是多行文本，除了最后一行外每个连续的行都必须用反斜杠结束

追加和插入只应用于单个行地址，不是一个范围内的行。不仅如此，这两个命令不会影响模式空间的内容，也就是说后续的匹配无法匹配到text的内容

### 转换操作

    [address]y/abc/xyz/

类似UNIX的tr命令，也是perl中的tr或叫y函数，依靠一一对应来替换字符

### 打印操作

    [address]p

和replace中flag的打印功能一样，一般与命令行选项*-n*或是*#n*一起使用，由于其对模式空间不会有任何影响，也可以匹配来调试sed脚本

```sed
    /^[\[.m/{
    p
    s/s//gp
    }
```

### 打印行号

    [address]=

除非抑制了行的自动输出（若有则只打印行号），否则行号和行本身都将被打印（换行分隔），*这个命令不能对一个范围内的行进行操作*

注意：=操作打印出来的行是模式空间的内容，如下例子，行被输出了两次，但两次内容是不一样的，即使=操作在s之前。p打印原行，=打印不带a的行

```sed
    /^[\[.m/{
    p
    =
    s/a//g
    }
```

### 下一步next

    [address]n

sed是将整个脚本应用于源文件中的每一行，n操作符会将当前模式空间中的行输出（如果没有-n之类的话），再把模式空间中的内容替换成下一行的内容，之后脚本文件上的操作都会下一行

perl程序来演示

    my $flag = 1;
    while my $line(<>) {
        <sedscript1> if $flag;
        $flag = 0;
        n => next if 某个条件;  * 成立时，相当于替换成下一行内容，并从sed2开始
        <sedscript2>
        $flag = 1;
    }

### 追加下一行NEXT

    [address]N

多行NEXT(N)命令通过读取新的行，并将它追加到模式空间的现有内容之后（换行符分隔），来创建多行模式空间

多行模式空间的换行符可以用\n来匹配，而元字符^只匹配空间中的第一个字符，同样$匹配模式空间的最后一个换行符（好奇怪，不过的确是这样）

注意：如果对最后一行即$执行NEXT操作，此时没有额外的行被读取，所以sed退出，甚至没有输出这一行，所以一般推荐使用`$!N`

### 多行删除

    [address]D

这也是用于多行的操作，用于删除模式空间中直到第一个换行符的内容（会输出），然后以模式空间剩余的内容从脚本顶端重新开始

```sed
    /^$/{
    N
    /^\n$/D
    s/$/ endline/
    }
```

### 多行打印

    [address]P

和D操作类似，只打印多行模式空间中直到第一个换行符的内容，一般出现在Next之后Delete之前

### 读写文件

    [address]r file
    [address]w file

读命令将在匹配成功的地址之后插入file的完整内容

写命令将模式空间中的内容追加到file中，每个脚本最多只能打开10个文件

### 退出

    [address]q

sed脚本退出，剩下的内容并不会被输出，一般是用来从文件中获取想要的信息后退出脚本

    sed -e '100q' test     * 用来打印前100行

### 保持空间

保持空间(hold space)是不同于模式空间的预留缓冲区，模式空间的内容可以复制到保持空间，而且保持空间的内容也可以复制到模式空间。影响保持空间的命令有

| 命令     | 缩写   | 功能                                 |
|----------|--------|--------------------------------------|
| Hold     | h 或 H | 将模式空间的内容复制或追加到保持空间 |
| Get      | g 或 G | 将保持空间的内容复制或追加到模式空间 |
| Exchange | x      | 交换保持空间和模式空间的内容         |

对于Hold和Get命令，同一个命令的大小写区别是，小写字母改写目的缓存区的内容（原来的内容并不会被输出），而大写字母命令追加缓存区的现有内容

Hold命令在保持空间的内容之后放置一个换行符，且后面跟随模式空间的内容(即使内容为空），Get命令模式空间的内容之后放置一个换行符，且后面跟随保持空间的内容

### 分支

    [address]b !label

branch命令用于在脚本中将控制转移到另一行

如果没有给出label，控制将被转移到脚本的结尾处，或执行label后面的行

定义`:label`

### 测试

    [address]t label

如果当前匹配地址的行上进行了成功的替换，在跳转到label处。同样的，如果没有给出label，控制将被转移到脚本的结尾处
